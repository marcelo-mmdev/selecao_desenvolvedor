1 - Explique o conceito de boxing e unboxing em C#. Quais s√£o as implica√ß√µes de
performance associadas a essas opera√ß√µes e como podem ser evitadas?

Boxing √© o processo de converter um tipo de valor (value type) ‚Äî como int, double, bool, struct ‚Äî
em um tipo de refer√™ncia (reference type), tipicamente um object ou uma interface que esse tipo implementa.
Isso ocorre porque os tipos de valor s√£o armazenados na stack (pilha) e os tipos de refer√™ncia na heap.
Quando voc√™ faz boxing, o valor √© copiado da stack para a heap, encapsulado em um objeto.

int numero = 10;
object obj = numero; // Boxing

Unboxing √© o processo inverso, converter um tipo de refer√™ncia de volta para um tipo de valor.
√â necess√°rio realizar um cast expl√≠cito para fazer unboxing.

object obj = 10;     // Boxing
int numero = (int)obj; // Unboxing

Boxing e unboxing envolvem, Aloca√ß√£o de mem√≥ria na heap. C√≥pia de dados entre stack e heap.
Convers√£o e verifica√ß√£o de tipo no unboxing, isso gera Sobrecarga de performance.
Aumento na press√£o do Garbage Collector (GC). Poss√≠vel impacto em loops ou opera√ß√µes massivas.

for (int i = 0; i < 100000; i++)
{
    object obj = i;     // Boxing em cada itera√ß√£o
    int num = (int)obj; // Unboxing
}
Esse c√≥digo cria 100 mil objetos na heap desnecessariamente.
Generics permitem trabalhar com tipos sem necessidade de boxing.
Antes de generics (.NET 1.1), cole√ß√µes como ArrayList armazenavam objetos, exigindo boxing de tipos de valor.

Sem generics (box/unbox)

ArrayList list = new ArrayList();
list.Add(10);                // Boxing
int num = (int)list[0];      // Unboxing

Com generics (evita boxing):
List<int> list = new List<int>();
list.Add(10);                // Sem boxing
int num = list[0];           // Sem unboxing

Prefira interfaces e m√©todos gen√©ricos para evitar boxing com structs.
Exemplo: void Process<T>(T value) { }

Evitar convers√µes desnecess√°rias para object ou interfaces n√£o gen√©ricas, Opera√ß√£o	O que faz	Impacto na performance
Boxing	Value type ‚Üí Reference type (object)	Cria objeto na heap
Unboxing	Reference type (object) ‚Üí Value type	Cast + c√≥pia de dados
Boxing e unboxing s√£o opera√ß√µes custosas, principalmente em cen√°rios de alto desempenho ou muitos objetos.
O uso de generics, structs otimizados e APIs modernas reduz drasticamente esses problemas no C# moderno.
***************************************************************************************************************************************************************************************
2 - Descreva as diferen√ßas entre struct e class em C#. Em que cen√°rios voc√™
escolheria usar uma struct em vez de uma class?

Em C#, struct e class s√£o dois tipos fundamentais, mas com diferen√ßas importantes de comportamento, sem√¢ntica e performance.
Quando usar struct em vez de class
Voc√™ deve considerar usar struct quando:
1. Imutabilidade √© desejada
structs devem representar objetos pequenos, imut√°veis como DateTime, Point, Color.
public struct Ponto
{
    public int X { get; }
    public int Y { get; }

    public Ponto(int x, int y)
    {
        X = x;
        Y = y;
    }
}
2. Uso intenso em performance cr√≠tica
Ideal quando h√° muitas inst√¢ncias sendo criadas em loops ou c√°lculos (ex: jogos, f√≠sica, gr√°ficos).
Evita aloca√ß√£o na heap e coleta de lixo (GC).
3. Tamanho pequeno (<=16 bytes idealmente)
Structs grandes podem gerar overhead na c√≥pia por valor.
Structs devem ser simples e leves.
4. Representar valores como entidades √∫nicas
Ex: Vector2, Color, Currency, Angle, etc.
Use struct quando... Use class quando...
Representa valor pequeno e imut√°vel	Representa objeto com identidade
Precisa de desempenho (sem GC)	Precisa de heran√ßa, refer√™ncia, null
N√£o precisa de heran√ßa	Precisa de comportamentos complexos
Opera√ß√µes simples e frequentes	Intera√ß√µes mais complexas ou longas

*********************************************************************************************************************************************
Quest√£o 3: Qual das seguintes afirma√ß√µes sobre delegates em C# √© INCORRETA?
a) Delegates s√£o tipos seguros que encapsulam refer√™ncias a m√©todos.
b) Um delegate pode referenciar tanto m√©todos est√°ticos quanto m√©todos de
inst√¢ncia.
c) Delegates s√£o primariamente utilizados para implementar interfaces de forma
an√¥nima.
d) Eventos em C# s√£o frequentemente implementados utilizando delegates.
Resposta.
a) Correta Delegates s√£o type-safe e encapsulam refer√™ncias a m√©todos com assinatura compat√≠vel.
b) Correta Delegates podem apontar para m√©todos est√°ticos ou de inst√¢ncia.
c) ‚ùå Incorreta Delegates n√£o s√£o usados para implementar interfaces. Isso √© papel das classes an√¥nimas ou express√µes lambda com interfaces funcionais. Delegates s√£o usados para encapsular m√©todos e trabalhar com callbacks/eventos.
d) Correta Eventos em C# s√£o baseados em delegates; eles usam delegates como tipo subjacente para notifica√ß√£o.

delegate void Operacao(int x, int y);

void Somar(int a, int b) => Console.WriteLine(a + b);
Operacao op = Somar;
op(3, 4); // Sa√≠da: 7
üîπ Interface
csharp
Copiar
Editar
interface IOperacao {
    void Executar(int x, int y);
}

class Soma : IOperacao {
    public void Executar(int x, int y) => Console.WriteLine(x + y);
}

Use delegate para passar m√©todos como par√¢metros, lidar com eventos ou callbacks.
Use interface para definir comportamentos estruturados a serem implementados por diferentes classes.
************************************************************************************************************************************************
Quest√£o 4: O que s√£o Extension Methods em C#? D√™ um exemplo pr√°tico de como voc√™
utilizaria um Extension Method para adicionar uma nova funcionalidade a um tipo existente
sem modificar seu c√≥digo-fonte original.

Extension Methods permitem adicionar novos m√©todos a tipos existentes (como string, int, ou at√© classes customizadas) sem alterar o c√≥digo original da classe nem criar uma subclasse.
S√£o m√©todos static definidos em uma static class.
O primeiro par√¢metro √© precedido pela palavra-chave this, e indica o tipo a ser estendido.

public static class StringExtensions
{
    public static int ContarPalavras(this string texto)
    {
        if (string.IsNullOrWhiteSpace(texto))
            return 0;

        return texto.Split(' ', StringSplitOptions.RemoveEmptyEntries).Length;
    }
}

string frase = "C# √© uma linguagem poderosa";
int total = frase.ContarPalavras(); // Resultado: 5

N√£o precisa alterar a classe original.
C√≥digo mais limpo, reutiliz√°vel e expressivo.
√ötil para trabalhar com APIs de terceiros ou tipos sealed como string, DateTime, etc.
************************************************************************************************************************************************
Quest√£o 5: Discuta o uso de async e await em C# para programa√ß√£o ass√≠ncrona. Quais
s√£o os benef√≠cios e como o fluxo de execu√ß√£o √© gerenciado? Apresente um exemplo
simples

async e await em C#: Programa√ß√£o Ass√≠ncrona Simplificada
async e await permitem escrever c√≥digo ass√≠ncrono de forma leg√≠vel, evitando callbacks complexos.
S√£o usados com m√©todos que retornam Task ou Task<T>.
async marca o m√©todo como ass√≠ncrono.
await aguarda a conclus√£o de uma Task, sem bloquear a thread.
Benef√≠cios
Evita bloqueio de threads (ex: UI ou servidor Web).
Melhora responsividade e escalabilidade.
Fluxo parecido com c√≥digo s√≠ncrono, facilitando manuten√ß√£o.
Fluxo de execu√ß√£o
M√©todo marcado com async come√ßa a executar.
Ao encontrar await, a execu√ß√£o pausa.
O controle retorna ao chamador (liberando a thread).
Quando a Task completa, a execu√ß√£o retoma do ponto do await.

public async Task<string> BuscarDadosAsync()
{
    using HttpClient client = new HttpClient();
    string resultado = await client.GetStringAsync("https://api.exemplo.com/dados");
    return resultado;
}

// Uso:
string dados = await BuscarDadosAsync();
async/await simplificam o uso de tarefas ass√≠ncronas.
Ideal para I/O-bound (ex: HTTP, arquivos, banco de dados).
Evita bloqueios e melhora o desempenho em apps escal√°veis.
************************************************************************************************************************************************
Quest√£o 6: Descreva o padr√£o de projeto Factory Method. Apresente um cen√°rio onde
sua aplica√ß√£o seria ben√©fica e como voc√™ o implementaria em C# para desacoplar a cria√ß√£o
de objetos.

O Factory Method √© um padr√£o que desacopla a cria√ß√£o de objetos da sua implementa√ß√£o concreta, delegando a responsabilidade de instanciar objetos para subclasses ou f√°bricas.
Fornece uma interface comum para criar objetos, mas permite que subclasses decidam qual classe instanciar.
Quando seu c√≥digo depende de uma interface ou classe base, mas n√£o deve conhecer as classes concretas.
Quando h√° varia√ß√µes de objetos a serem criados e isso precisa ser controlado de forma flex√≠vel e extens√≠vel.

public interface ITransporte
{
    void Entregar();
}
Implementa√ß√µes concretas
public class Caminhao : ITransporte
{
    public void Entregar() => Console.WriteLine("Entregando por caminh√£o");
}

public class Navio : ITransporte
{
    public void Entregar() => Console.WriteLine("Entregando por navio");
}
Factory Method (classe base)
public abstract class Logistica
{
    public abstract ITransporte CriarTransporte();
}
F√°bricas concretas

public class LogisticaTerrestre : Logistica
{
    public override ITransporte CriarTransporte() => new Caminhao();
}

public class LogisticaMaritima : Logistica
{
    public override ITransporte CriarTransporte() => new Navio();
}
Uso
Logistica logistica = new LogisticaTerrestre(); // ou LogisticaMaritima
ITransporte transporte = logistica.CriarTransporte();
transporte.Entregar();
Desacoplamento entre o c√≥digo cliente e as classes concretas.
Facilidade de extens√£o para novos tipos de produto.
Encapsula a l√≥gica de cria√ß√£o, mantendo o c√≥digo mais limpo.
************************************************************************************************************************************************
Quest√£o 7: Explique o padr√£o Decorator. Como ele permite adicionar responsabilidades a
objetos dinamicamente, e qual a sua diferen√ßa em rela√ß√£o √† heran√ßa tradicional para
estender funcionalidades?

O padr√£o Decorator permite adicionar responsabilidades a um objeto dinamicamente, sem alterar sua estrutura original e sem modificar a classe base.
Usa composi√ß√£o ao inv√©s de heran√ßa.
Objetos decoradores implementam a mesma interface do objeto original e o envolvem (wrap).
Quando voc√™ precisa adicionar funcionalidades em tempo de execu√ß√£o.
Quando quer evitar uma hierarquia extensa de subclasses para cada combina√ß√£o de comportamento.
Diferen√ßa para Heran√ßa Tradicional
Decorator	Heran√ßa Tradicional
Adiciona funcionalidades em tempo de execu√ß√£o	Adiciona funcionalidades em tempo de compila√ß√£o
Usa composi√ß√£o	Usa heran√ßa direta
Mais flex√≠vel e extens√≠vel	Menos flex√≠vel, pode gerar muitas subclasses
Interface base
public interface ICafe
{
    string Descricao();
    double Custo();
}
Implementa√ß√£o concreta
public class CafeSimples : ICafe
{
    public string Descricao() => "Caf√© simples";
    public double Custo() => 5.0;
}
Decoradores
class ComLeite : ICafe
{
    private ICafe _cafe;
    public ComLeite(ICafe cafe) => _cafe = cafe;

    public string Descricao() => _cafe.Descricao() + " + leite";
    public double Custo() => _cafe.Custo() + 2.0;
}

public class ComChocolate : ICafe
{
    private ICafe _cafe;
    public ComChocolate(ICafe cafe) => _cafe = cafe;

    public string Descricao() => _cafe.Descricao() + " + chocolate";
    public double Custo() => _cafe.Custo() + 3.0;
}
Uso
ICafe cafe = new CafeSimples();
cafe = new ComLeite(cafe);
cafe = new ComChocolate(cafe);

Console.WriteLine(cafe.Descricao()); // Caf√© simples + leite + chocolate
Console.WriteLine(cafe.Custo());     // 10.0

Decorator = adicionar comportamento em tempo de execu√ß√£o.
Evita subclasses desnecess√°rias.
Promove abertura/extens√£o sem modifica√ß√£o.
************************************************************************************************************************************************
Quest√£o 8: Qual padr√£o de projeto √© mais adequado para garantir que uma classe tenha
apenas uma inst√¢ncia e fornecer um ponto de acesso global a essa inst√¢ncia?
a) Builder
b) Singleton
c) Prototype
d) Facade

Resposta correta: b) Singleton
Garante que **uma classe tenha apenas uma √∫nica inst√¢ncia em todo o sistema e fornece um ponto de acesso global a ela.
public class Configuracao
{
    private static readonly Configuracao _instancia = new Configuracao();

    // Construtor privado impede inst√¢ncia externa
    private Configuracao() { }

    public static Configuracao Instancia => _instancia;
}
Uso:
var config = Configuracao.Instancia;
Outras op√ß√µes incorretas
a) Builder: constr√≥i objetos complexos passo a passo.
c) Prototype: clona objetos existentes.
d) Facade: fornece uma interface simplificada para um subsistema.
************************************************************************************************************************************************
Quest√£o 9: O padr√£o Strategy √© frequentemente usado para encapsular algoritmos
intercambi√°veis. Descreva um problema que voc√™ resolveria com o padr√£o Strategy e como
as diferentes estrat√©gias seriam gerenciadas pela classe de contexto

Permite encapsular algoritmos intercambi√°veis em classes separadas e alter√°-los em tempo de execu√ß√£o sem modificar o c√≥digo do cliente.
Imagine um sistema de c√°lculo de frete que muda conforme o tipo de entrega:
Frete padr√£o (PAC)
Frete expresso (Sedex)
Frete internacional
Em vez de usar if/else ou switch, usamos Strategy para manter o c√≥digo flex√≠vel e extens√≠vel.
Interface da estrat√©gia

public interface ICalculoFrete
{
    decimal Calcular(decimal peso);
}
Estrat√©gias concretas
public class FretePadrao : ICalculoFrete
{
    public decimal Calcular(decimal peso) => peso * 5;
}

public class FreteExpresso : ICalculoFrete
{
    public decimal Calcular(decimal peso) => peso * 10;
}

public class FreteInternacional : ICalculoFrete
{
    public decimal Calcular(decimal peso) => peso * 20 + 50;
}
Classe de contexto
public class ServicoFrete
{
    private ICalculoFrete _estrategia;

    public ServicoFrete(ICalculoFrete estrategia) => _estrategia = estrategia;

    public void DefinirEstrategia(ICalculoFrete estrategia) => _estrategia = estrategia;

    public decimal CalcularFrete(decimal peso) => _estrategia.Calcular(peso);
}
Uso
var servico = new ServicoFrete(new FretePadrao());
Console.WriteLine(servico.CalcularFrete(10)); // 50
servico.DefinirEstrategia(new FreteExpresso());
Console.WriteLine(servico.CalcularFrete(10)); // 100
Evita condicionais extensos.
Facilita a manuten√ß√£o e extens√£o (basta criar nova estrat√©gia).
Permite mudar o algoritmo em tempo de execu√ß√£o.

************************************************************************************************************************************************
Quest√£o 10: O Princ√≠pio da Responsabilidade √önica (SRP) afirma que uma classe deve ter
apenas um motivo para mudar. Como a viola√ß√£o desse princ√≠pio pode impactar a
manutenibilidade e testabilidade do c√≥digo? D√™ um exemplo em C#.

Princ√≠pio da Responsabilidade √önica (Single Responsibility Principle)
Uma classe deve ter apenas um motivo para mudar, ou seja, uma √∫nica responsabilidade.
Baixa coes√£o: a classe faz coisas demais, ficando dif√≠cil de entender.
Alta fragilidade: mudar um comportamento pode quebrar outros.
Dificuldade para testar: classes grandes com m√∫ltiplas responsabilidades exigem testes complexos e com muitos mocks/stubs.
Baixa reutiliza√ß√£o: responsabilidades misturadas tornam o reaproveitamento dif√≠cil.
Exemplo de viola√ß√£o (ruim)

public class Relatorio
{
    public string GerarConteudo()
    {
        return "Dados do relat√≥rio...";
    }

    public void SalvarEmArquivo(string conteudo)
    {
        File.WriteAllText("relatorio.txt", conteudo);
    }

    public void EnviarEmail(string conteudo)
    {
        // L√≥gica para envio de e-mail
    }
}
A classe gera conte√∫do, salva em arquivo e envia e-mail ‚Äî tr√™s responsabilidades distintas.
Qualquer altera√ß√£o em I/O, e-mail ou conte√∫do impacta essa √∫nica classe.
Refatorado com SRP
public class GeradorRelatorio
{
    public string GerarConteudo() => "Dados do relat√≥rio...";
}
public class RelatorioArquivo
{
    public void Salvar(string conteudo) => File.WriteAllText("relatorio.txt", conteudo);
}
public class EnviadorEmail
{
    public void Enviar(string conteudo) { /* l√≥gica de envio */ }
}
Agora, cada classe tem uma √∫nica responsabilidade, podendo ser testada e modificada de forma isolada.
************************************************************************************************************************************************
Quest√£o 11: Explique o Princ√≠pio Aberto/Fechado (OCP). Como podemos projetar classes
em C# que sejam abertas para extens√£o, mas fechadas para modifica√ß√£o, utilizando, por
exemplo, heran√ßa ou composi√ß√£o com interfaces?

‚ÄúSoftware deve estar aberto para extens√£o, mas fechado para modifica√ß√£o.‚Äù
Ou seja, podemos estender o comportamento de uma classe sem alterar seu c√≥digo-fonte original.
Usando heran√ßa: criar classes base est√°veis e estender via subclasses.
Usando interfaces e composi√ß√£o: programar para abstra√ß√µes, permitindo trocar implementa√ß√µes sem alterar c√≥digo cliente.
Exemplo usando interfaces e composi√ß√£o
public interface IDesconto
{
    decimal Aplicar(decimal valor);
}

public class DescontoNatal : IDesconto
{
    public decimal Aplicar(decimal valor) => valor * 0.9m; // 10% de desconto
}

public class DescontoAnoNovo : IDesconto
{
    public decimal Aplicar(decimal valor) => valor * 0.8m; // 20% de desconto
}

public class CalculadoraPreco
{
    private readonly IDesconto _desconto;

    public CalculadoraPreco(IDesconto desconto)
    {
        _desconto = desconto;
    }

    public decimal Calcular(decimal valor) => _desconto.Aplicar(valor);
}
Uso:
var desconto = new DescontoNatal();
var calc = new CalculadoraPreco(desconto);
Console.WriteLine(calc.Calcular(100)); // 90
Para adicionar um novo desconto, criamos uma nova classe que implementa IDesconto ‚Äî sem modificar CalculadoraPreco.
Mantenha classes est√°veis (fechadas para modifica√ß√£o).
Permita extens√£o via subclasses ou novas implementa√ß√µes de interfaces.
Promove c√≥digo mais seguro, test√°vel e escal√°vel.
************************************************************************************************************************************************
Quest√£o 12: Qual a diferen√ßa entre UNION e UNION ALL em SQL? Em que situa√ß√µes a
performance pode ser afetada pela escolha entre um e outro?

Diferen√ßa entre UNION e UNION ALL em SQL
Caracter√≠stica	UNION	UNION ALL
Combina resultados	Sim	Sim
Remove duplicatas	Sim (elimina linhas duplicadas)	N√£o (mant√©m todas as linhas)
Performance	Mais lenta, pois faz compara√ß√£o extra para eliminar duplicatas	Mais r√°pida, pois simplesmente concatena resultados
Uso comum	Quando voc√™ precisa de resultados √∫nicos	Quando quer todos os registros, inclusive duplicados
UNION exige um passo adicional de ordenar e comparar as linhas para remover duplicatas, o que pode ser custoso em tabelas grandes.
UNION ALL n√£o faz essa opera√ß√£o extra, ent√£o √© mais r√°pido e consome menos recursos.
Use UNION quando precisar garantir que o resultado n√£o contenha duplicatas.
Use UNION ALL quando tiver certeza que as consultas n√£o retornam duplicatas ou quando duplicatas s√£o desejadas, priorizando performance.
************************************************************************************************************************************************
Quest√£o 13: Em PL/SQL (Oracle 10g), explique o que s√£o Packages. Quais s√£o as
vantagens de agrupar procedures, functions, types e vari√°veis em um package?


Um Package √© um agrupamento l√≥gico de procedures, functions, tipos (types), vari√°veis, constantes e cursores relacionados.
√â dividido em duas partes:
Specification (spec): interface p√∫blica, declara os elementos vis√≠veis externamente.
Body: implementa√ß√£o das procedures, functions e detalhes internos.
Organiza√ß√£o e modulariza√ß√£o
Agrupa c√≥digo relacionado, facilitando a manuten√ß√£o e entendimento.
Encapsulamento
Esconde detalhes da implementa√ß√£o no corpo do package, expondo s√≥ o que √© necess√°rio.
Reuso de c√≥digo
Permite reutilizar fun√ß√µes/procedures comuns em v√°rios programas.
Performance
ackages s√£o carregados na mem√≥ria uma √∫nica vez e ficam dispon√≠veis para m√∫ltiplas chamadas
Reduz overhead de compila√ß√£o e melhora desempenho.
Controle de acesso
√â poss√≠vel definir que apenas alguns elementos do package sejam p√∫blicos.
Manuten√ß√£o facilitada
Atualiza√ß√µes em procedures internas n√£o afetam programas que usam a spec, desde que a interface n√£o mude.

CREATE OR REPLACE PACKAGE minha_biblioteca IS
  PROCEDURE saudacao(nome IN VARCHAR2);
END minha_biblioteca;
/

CREATE OR REPLACE PACKAGE BODY minha_biblioteca IS
  PROCEDURE saudacao(nome IN VARCHAR2) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Ol√°, ' || nome);
  END saudacao;
END minha_biblioteca;
/

************************************************************************************************************************************************
Quest√£o 14: No Oracle 10g, qual das seguintes op√ß√µes √© a melhor forma de lidar com um
erro espec√≠fico (ex: NO_DATA_FOUND) dentro de um bloco PL/SQL? 
) Usar um IF statement para checar SQLCODE ap√≥s cada DML.
b) Declarar uma exce√ß√£o nomeada e trat√°-la na se√ß√£o EXCEPTION WHEN.
c) Usar GOTO para pular para uma se√ß√£o de tratamento de erro.
d) Permitir que o erro se propague e seja tratado pela aplica√ß√£o cliente.

Resposta correta: b) Declarar uma exce√ß√£o nomeada e trat√°-la na se√ß√£o EXCEPTION WHEN.

Em PL/SQL, o m√©todo correto e estruturado para tratar erros espec√≠ficos (como NO_DATA_FOUND) √© usar a se√ß√£o EXCEPTION com cl√°usulas WHEN para capturar e tratar essas exce√ß√µes.
BEGIN
  SELECT nome INTO v_nome FROM clientes WHERE id = 10;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('Cliente n√£o encontrado.');
END;
Por que as outras op√ß√µes s√£o inadequadas?
a) IF com SQLCODE: √© poss√≠vel, mas n√£o √© recomendado pois deixa o c√≥digo confuso e repetitivo.

c) GOTO: uso de GOTO √© considerado m√° pr√°tica e n√£o √© necess√°rio para tratamento de erros.

d) Permitir que o erro se propague: nem sempre desej√°vel, pois pode causar falhas inesperadas; √© melhor tratar erros conhecidos diretamente no PL/SQL.
************************************************************************************************************************************************
Quest√£o 15: O que s√£o triggers de banco de dados no Oracle? Descreva um cen√°rio onde
voc√™ utilizaria um trigger AFTER INSERT em uma tabela para manter a integridade
referencial ou registrar auditoria.

Triggers s√£o blocos de c√≥digo PL/SQL que disparam automaticamente em resposta a eventos DML (INSERT, UPDATE, DELETE) ou DDL em tabelas ou views.
Executam antes ou depois da opera√ß√£o ocorrer (BEFORE ou AFTER).
Trigger AFTER INSERT
Executa ap√≥s uma inser√ß√£o ser confirmada na tabela
Usado para a√ß√µes dependentes da inser√ß√£o bem-sucedida.
Registrar auditoria automaticamente ap√≥s inserir um registro na tabela VENDAS:
Toda vez que uma nova venda √© inserida, grava-se um registro na tabela AUDITORIA_VENDAS com dados da opera√ß√£o.
CREATE OR REPLACE TRIGGER trg_audit_vendas
AFTER INSERT ON vendas
FOR EACH ROW
BEGIN
  INSERT INTO auditoria_vendas (venda_id, data_insercao, usuario)
  VALUES (:NEW.id, SYSDATE, USER);
END;
/
Outros usos comuns de triggers AFTER INSERT
Manter integridade referencial em casos onde constraints n√£o cobrem a regra.
Atualizar dados em tabelas relacionadas.
Disparar notifica√ß√µes ou atualiza√ß√µes de cache.
************************************************************************************************************************************************
Quest√£o 16: Escreva uma consulta SQL para selecionar o nome dos departamentos
(Departamentos.NomeDepto) e a m√©dia salarial (Funcionarios.Salario) dos
funcion√°rios de cada departamento, mas apenas para os departamentos cuja m√©dia salarial
seja superior a R$ 5000. Assuma as tabelas:
Departamentos (IDDepto, NomeDepto)
Funcionarios (IDFunc, NomeFunc, IDDepto, Salario)

SELECT d.NomeDepto, AVG(f.Salario) AS MediaSalarial
FROM Departamentos d
JOIN Funcionarios f ON d.IDDepto = f.IDDepto
GROUP BY d.NomeDepto
HAVING AVG(f.Salario) > 5000;
Explica√ß√£o r√°pida:
Fazemos o JOIN entre Departamentos e Funcionarios pela chave IDDepto.
Agrupamos por departamento (GROUP BY d.NomeDepto).
Calculamos a m√©dia salarial com AVG(f.Salario).
Filtramos os grupos para mostrar somente os departamentos cuja m√©dia salarial √© maior que 5000 usando HAVING.
Se precisar, posso ajudar a adaptar para Oracle PL/SQL ou incluir ordena√ß√£o. Quer?
Para Oracle PL/SQL, a consulta continua a mesma, j√° que PL/SQL suporta comandos SQL padr√£o. Vou adicionar uma ordena√ß√£o decrescente pela m√©dia salarial, que costuma ser √∫til:
SELECT d.NomeDepto, AVG(f.Salario) AS MediaSalarial
FROM Departamentos d
JOIN Funcionarios f ON d.IDDepto = f.IDDepto
GROUP BY d.NomeDepto
HAVING AVG(f.Salario) > 5000
ORDER BY MediaSalarial DESC;
Como usar em PL/SQL (exemplo simples de bloco an√¥nimo):
BEGIN
  FOR rec IN (
    SELECT d.NomeDepto, AVG(f.Salario) AS MediaSalarial
    FROM Departamentos d
    JOIN Funcionarios f ON d.IDDepto = f.IDDepto
    GROUP BY d.NomeDepto
    HAVING AVG(f.Salario) > 5000
    ORDER BY MediaSalarial DESC
  ) LOOP
    DBMS_OUTPUT.PUT_LINE('Depto: ' || rec.NomeDepto || ', M√©dia: ' || rec.MediaSalarial);
  END LOOP;
END;
/
Aqui est√° um exemplo de procedure PL/SQL que recebe como par√¢metro o valor m√≠nimo da m√©dia salarial e retorna os departamentos com m√©dia salarial superior a esse valor:
CREATE OR REPLACE PROCEDURE listar_departamentos_com_media(
  p_media_minima IN NUMBER
) IS
BEGIN
  FOR rec IN (
    SELECT d.NomeDepto, AVG(f.Salario) AS MediaSalarial
    FROM Departamentos d
    JOIN Funcionarios f ON d.IDDepto = f.IDDepto
    GROUP BY d.NomeDepto
    HAVING AVG(f.Salario) > p_media_minima
    ORDER BY MediaSalarial DESC
  ) LOOP
    DBMS_OUTPUT.PUT_LINE('Departamento: ' || rec.NomeDepto || ', M√©dia Salarial: ' || TO_CHAR(rec.MediaSalarial, 'FM9999990.00'));
  END LOOP;
END;
/
BEGIN
  listar_departamentos_com_media(5000);
END;
/
